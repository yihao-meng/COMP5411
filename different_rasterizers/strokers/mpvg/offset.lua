-- Stroke-to-fill conversion program and test harness
-- Copyright (C) 2020 Diego Nehab
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as published
-- by the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- Contact information: diego.nehab@gmail.com
--
local _M = {}

-- TODO: we can reduce the number of segments generated by
-- simplifying the inner joins. To do so, we have to either
-- delay output of the first side of the wedge to when we are
-- processing the join, or to chain some kind of filter that
-- receives the result of the join and simplifies it after
-- the fact. For each inner join, this would eliminate at
-- least one segment, but would require us to compute intersections.

local abs = math.abs
local max = math.max
local sqrt = math.sqrt
local acos = math.acos
local cos = math.cos
local sin = math.sin

local util = require"strokers.mpvg.util"
local dot2 = util.dot2
local norm2 = util.norm2
local apply2 = util.apply2
local sign = util.sign
local det2 = util.det2
local negligible = util.negligible
local significant = util.significant
local distinct = util.distinct
local FLT_MIN = util.FLT_MIN

local intersect = require"strokers.mpvg.intersect"
local segmentsq = intersect.segmentsq
local linesi = intersect.linesi
local circlesi = intersect.circlesi
local circlelinei = intersect.circlelinei

local function capbutt(x00m, y00m, dx, dy, x00p, y00p, output)
    output:linear_segment(x00m, y00m, x00p, y00p)
end

local function capround(x00m, y00m, dx, dy, x00p, y00p, output)
    output:rational_quadratic_segment(x00m, y00m, -dx, -dy, 0., x00p, y00p)
end

local function capsquare(x00m, y00m, dx, dy, x00p, y00p, output)
    local smx, smy = x00m-dx, y00m-dy
    local spx, spy = x00p-dx, y00p-dy
    output:linear_segment(x00m, y00m, smx, smy)
    output:linear_segment(smx, smy, spx, spy)
    output:linear_segment(spx, spy, x00p, y00p)
end

local function captriangle(x00m, y00m, dx, dy, x00p, y00p, output)
    local sx, sy = .5*(x00m+x00p)-dx, .5*(y00m+y00p)-dy
    output:linear_segment(x00m, y00m, sx, sy)
    output:linear_segment(sx, sy, x00p, y00p)
end

local function capfletching(x00m, y00m, dx, dy, x00p, y00p, output)
    local smx, smy = x00m-dx, y00m-dy
    local x, y = .5*(x00m+x00p), .5*(y00m+y00p)
    local spx, spy = x00p-dx, y00p-dy
    output:linear_segment(x00m, y00m, smx, smy)
    output:linear_segment(smx, smy, x, y)
    output:linear_segment(x, y, spx, spy)
    output:linear_segment(spx, spy, x00p, y00p)
end

local caps = {
    butt = capbutt,
    round = capround,
    square = capsquare,
    triangle = captriangle,
    fletching = capfletching,
}

local function cap(dashed, iter, first, last, style, ctol, moveto, output)
    local capper = {}

    function capper:end_segment(s, t, x1, y1)
        -- curvatures are irrelevant for caps
    end

    function capper:begin_segment(s, t, x0, y0)
        -- curvatures are irrelevant for caps
    end

    function capper:linear_segment_with_length(x0, y0, len, x1, y1)
        local inv_len = .5*style.width/len
        local dx, dy = (x1-x0)*inv_len, (y1-y0)*inv_len
        local x00p, y00p = x0-dy, y0+dx
        local x00m, y00m = x0+dy, y0-dx
        if moveto then output:begin_closed_contour(nil, x00m, y00m) end
        caps[style.cap](x00m, y00m, dx, dy, x00p, y00p, output)
        return true -- abort iteration
    end

    function capper:degenerate_segment(x0, y0, dx0, dy0, dx1, dy1, x1, y1)
        local len0 = sqrt(dx0*dx0+dy0*dy0)
        local inv_len0 = .5*style.width/len0
        local dx, dy = dx0*inv_len0, dy0*inv_len0
        local x00p, y00p = x0-dy, y0+dx
        local x00m, y00m = x0+dy, y0-dx
        if moveto then output:begin_closed_contour(nil, x00m, y00m) end
        caps[style.cap](x00m, y00m, dx, dy, x00p, y00p, output)
        return true -- abort iteration
    end

    iter(dashed, capper, first+1, last-1)
end

local function sq(s)
    return s*s
end

local function arc(x0, y0, cx, cy, r, x1, y1, output)
    local cos_2a = dot2(x0-cx, y0-cy, x1-cx, y1-cy) / sq(r)
    local cos_a = sqrt(abs(.5*(cos_2a+1.)))
    -- intersection between tangents to circle
    local bx, by, bw = linesi(x0,y0, x0-(y0-cy),y0+(x0-cx),
        x1,y1, x1-(y1-cy),y1+(x1-cx))
    -- direction from center to intersection
    if bw < 0 then bx, by, bw = -bx, -by, -bw end
    bx, by = bx-cx*bw, by-cy*bw
    -- normalize
    local el = sqrt(norm2(bx, by))
    if significant(el) then
        bx, by = bx*r/el, by*r/el
        output:rational_quadratic_segment(
            x0, y0,
            bx+cos_a*cx, by+cos_a*cy, cos_a,
            x1, y1)
    else
        output:linear_segment(x0, y0, x1, y1)
    end
end

local function outermiterclip(
    dx0, dy0, x00, y00, -- tangent direction and first wedge point
    s01, t01, x, y, s10, t10, -- curvatures and middle wedge point
    x11, y11, dx1, dy1, -- tangent directions and last wedge point
    style, ctol, output)
    local x00p, y00p = x00-dy0, y00+dx0
    local x01p, y01p = x-dy0, y+dx0
    local x10p, y10p = x-dy1, y+dx1
    local x11p, y11p = x11-dy1, y11+dx1
    local sw = .5*style.width
    local ml = style.miter_limit
    -- find miter corner
    local mx, my, mw = linesi(x00p,y00p, x01p,y01p, x10p,y10p, x11p,y11p)
    -- if miter is within limit, use intersection
    if sq(mx-x*mw)+sq(my-y*mw) < sq(ml*mw) then
        local xi, yi = mx/mw, my/mw
        output:linear_segment(x01p, y01p, xi, yi)
        output:linear_segment(xi, yi, x10p, y10p)
    else
        -- clip the miter at distance from the shared corner
        -- that is equal to the miter limit times the stroke
        -- width, parallel to the bevel.
        local dxi, dyi = mx-mw*x, my-mw*y -- direction from x,y to xi, yi
        local d = ml/sqrt(norm2(dxi, dyi))
        -- point at the miter_limit distance away from x,y in direction dxi, dyi
        local px, py = x+d*dxi, y+d*dyi
        local c0x, c0y, c0w = linesi(x00p,y00p, x01p,y01p, px,py, px-dyi,py+dxi)
        c0x, c0y = c0x/c0w, c0y/c0w
        local c1x, c1y, c1w = linesi(x10p,y10p, x11p,y11p, px,py, px-dyi,py+dxi)
        c1x, c1y = c1x/c1w, c1y/c1w
        output:linear_segment(x01p, y01p, c0x, c0y)
        output:linear_segment(c0x, c0y, c1x, c1y)
        output:linear_segment(c1x, c1y, x10p, y10p)
    end
end

local function outermiter(
    dx0, dy0, x00, y00, -- tangent direction and first wedge point
    s01, t01, x, y, s10, t10, -- curvatures and middle wedge point
    x11, y11, dx1, dy1, -- tangent directions and last wedge point
    style, ctol, output)
    local x00p, y00p = x00-dy0, y00+dx0
    local x01p, y01p = x-dy0, y+dx0
    local x10p, y10p = x-dy1, y+dx1
    local x11p, y11p = x11-dy1, y11+dx1
    local sw = .5*style.width
    local ml = style.miter_limit
    -- find miter corner
    local mx, my, mw = linesi(x00p,y00p, x01p,y01p, x10p,y10p, x11p,y11p)
    -- if miter is within limit, use intersection
    if sq(mx-x*mw)+sq(my-y*mw) < sq(sw*ml*mw) then
        local xi, yi = mx/mw, my/mw
        output:linear_segment(x01p, y01p, xi, yi)
        output:linear_segment(xi, yi, x10p, y10p)
    else
        -- simply convert to a bevel.
        output:linear_segment(x01p, y01p, x10p, y10p)
    end
end

local function outerround(
    dx0, dy0, x00, y00, -- tangent direction and first wedge point
    s01, t01, x, y, s10, t10, -- curvatures and middle wedge point
    x11, y11, dx1, dy1, -- tangent directions and last wedge point
    style, ctol, output)
    local sw = .5*style.width
    local x01p, y01p = x-dy0, y+dx0
    local x10p, y10p = x-dy1, y+dx1
    arc(x01p, y01p, x, y, sw, x10p, y10p, output)
end

local function outerbevel(
    dx0, dy0, x00, y00, -- tangent direction and first wedge point
    s01, t01, x, y, s10, t10, -- curvatures and middle wedge point
    x11, y11, dx1, dy1, -- tangent directions and last wedge point
    style, ctol, output)
    local x01p, y01p = x-dy0, y+dx0
    local x10p, y10p = x-dy1, y+dx1
    output:linear_segment(x01p, y01p, x10p, y10p)
end

local function closest(x,y, x0,y0, x1,y1)
    if norm2(x-x0, y-y0) < norm2(x-x1, y-y1) then return x0, y0
    else return x1, y1 end
end

-- limit is 0.5*stroke.width*stroke.miter_limit
local function outerarcslimit(x01p,y01p, x,y, x10p,y10p, ix,iy, limit)
    -- compute circle/line that goes through x,y and ix,iy,
    -- and is tangent to the bissector of the wedge x01p,y01p, x,y, x10p,y10p
    -- the center must be along the line through x,y in the
    -- direction perpendicular to the bisector. it must also
    -- be in the mediatrix of x,y and ix,iy since it  goes
    -- through both points. so the center is the
    -- intersection between the two lines.
    local mx, my = .5*(x+ix), .5*(y+iy)
    local dx, dy = x-ix, y-iy
    local cx, cy, cw = linesi(x,y, x-(y01p+y10p-2.*y), y+(x01p+x10p-2.*x),
         mx,my, mx-dy, my+dx)
    -- if the center is at infinity, the circle degenerates to a line
    if negligible(cw) then
        -- check if ix,iy is further than the miter limit along line
        local d2 = norm2(dx, dy)
        if d2 > limit*limit then
            local inv_d = 1./sqrt(d2)
            -- if so, return clipping line
            dx, dy = inv_d*dx, inv_d*dy
            local elx, ely = x-limit*dx, y-limit*dy
            return elx, ely, -dy, dx
        end
    -- if it is indeed a circle
    else
        -- check if ix,iy is further than the miter limit along arc
        cx, cy = cx/cw, cy/cw
        local dpx, dpy = x-cx, y-cy
        local dix, diy = ix-cx, iy-cy
        local r2 = norm2(dpx, dpy)
        local inv_r2 = 1./r2
        local cos_a = inv_r2*dot2(dpx,dpy, dix,diy)
        if sq(acos(cos_a)) > limit*limit*inv_r2 then
            -- if so, return clipping line
            local inv_r = sqrt(inv_r2)
            local b = sign(det2(dpx,dpy, dix,diy))*limit*inv_r
            local c, s = cos(b), sin(b)
            local elx, ely = apply2(c, -s, s, c, dpx, dpy)
            return elx+cx,ely+cy, inv_r*elx,inv_r*ely
        end
    end
end

-- assumes curvature denominators non-negative positive
local function outerarcscircles(
    dx0, dy0, x00, y00, -- tangent direction and first wedge point
    s01, t01, x, y, s10, t10, -- curvatures and middle wedge point
    x11, y11, dx1, dy1, -- tangent directions and last wedge point
    style, ctol, output)
    local sw = .5*style.width
    local inv_sw = 1./sw
    local nx0, ny0 = -dy0*inv_sw, dx0*inv_sw
    local r0 = t01/s01
    local cx0, cy0 = x+r0*nx0, y+r0*ny0
    r0 = abs(r0 - sw)
    local nx1, ny1 = -dy1*inv_sw, dx1*inv_sw
    local r1 = t10/s10
    local cx1, cy1 = x+r1*nx1, y+r1*ny1
    r1 = abs(r1 - sw)
    local iq, i0x, i0y, i1x, i1y = circlesi(cx0,cy0, r0, cx1,cy1, r1)
    if iq ~= "intersect" then
        return outermiterclip(dx0,dy0, x00,y00, s01,t01, x,y, s10,t10,
            x11,y11, dx1,dy1, style, ctol, output)
    end
    local ix, iy = closest(x,y, i0x,i0y, i1x,i1y)
    local x01p, y01p = x-dy0, y+dx0
    local x10p, y10p = x-dy1, y+dx1
    -- check if intersection is past miter limit
    local elx, ely, edx, edy = outerarcslimit(x01p,y01p, x,y, x10p,y10p,
        ix,iy, sw*style.miter_limit)
    -- if so
    if elx then -- and ely and delx and dely
        iq, i0x, i0y, i1x, i1y = circlelinei(cx0,cy0,r0,elx,ely,edx,edy)
        assert(iq == "intersect", "should have intersected")
        local e0x, e0y = closest(elx,ely, i0x,i0y, i1x,i1y)
        iq, i0x, i0y, i1x, i1y = circlelinei(cx1,cy1,r1,elx,ely,edx,edy)
        assert(iq == "intersect", "should have intersected")
        local e1x, e1y = closest(elx,ely, i0x,i0y, i1x,i1y)
        arc(x01p, y01p, cx0, cy0, r0, e0x, e0y, output)
        output:linear_segment(e0x,e0y, e1x, e1y)
        arc(e1x, e1y, cx1, cy1, r1, x10p, y10p, output)
    else
        arc(x01p, y01p, cx0, cy0, r0, ix, iy, output)
        arc(ix, iy, cx1, cy1, r1, x10p, y10p, output)
    end
end

local function outerarcscircleline(
    dx0, dy0, x00, y00, -- tangent direction and first wedge point
    s01, t01, x, y, s10, t10, -- curvatures and middle wedge point
    x11, y11, dx1, dy1, -- tangent directions and last wedge point
    style, ctol, output)
    local sw = .5*style.width
    local inv_sw = 1./sw
    local nx0, ny0 = -dy0*inv_sw, dx0*inv_sw
    local r0 = t01/s01
    local cx0, cy0 = x+r0*nx0, y+r0*ny0
    r0 = abs(r0 - sw)
    local x01p, y01p = x-dy0, y+dx0
    local x10p, y10p = x-dy1, y+dx1
    local iq, i0x, i0y, i1x, i1y = circlelinei(cx0,cy0, r0,
        x10p,y10p, dx1*inv_sw, dy1*inv_sw)
    if iq ~= "intersect" then
        return outermiterclip(dx0,dy0, x00,y00, s01,t01, x,y, s10,t10,
            x11,y11, dx1,dy1, style, ctol, output)
    end
    local ix, iy = closest(x,y, i0x,i0y, i1x,i1y)
    -- check if intersection is past miter limit
    local elx, ely, edx, edy = outerarcslimit(x01p,y01p, x,y, x10p,y10p,
        ix,iy, sw*style.miter_limit)
    -- if so
    if elx then -- and ely and delx and dely
        iq, i0x, i0y, i1x, i1y = circlelinei(cx0,cy0,r0,elx,ely,edx,edy)
        assert(iq == "intersect", "should have intersected")
        local e0x, e0y = closest(elx,ely, i0x,i0y, i1x,i1y)
        local e1x, e1y, e1w = linesi(elx,ely, elx+edx,ely+edy, x10p,y10p, ix,iy)
        assert(significant(e1w), "should have intersected")
        e1x, e1y = e1x/e1w, e1y/e1w
        arc(x01p, y01p, cx0, cy0, r0, e0x, e0y, output)
        output:linear_segment(e0x,e0y, e1x, e1y)
        output:linear_segment(e1x, e1y, x10p, y10p)
    else
        arc(x01p, y01p, cx0, cy0, r0, ix, iy, output)
        output:linear_segment(ix, iy, x10p, y10p)
    end
end

local function outerarcslinecircle(
    dx0, dy0, x00, y00, -- tangent direction and first wedge point
    s01, t01, x, y, s10, t10, -- curvatures and middle wedge point
    x11, y11, dx1, dy1, -- tangent directions and last wedge point
    style, ctol, output)
    local sw = .5*style.width
    local inv_sw = 1./sw
    local nx1, ny1 = -dy1*inv_sw, dx1*inv_sw
    local r1 = t10/s10
    local cx1, cy1 = x+r1*nx1, y+r1*ny1
    r1 = abs(r1 - sw)
    local x01p, y01p = x-dy0, y+dx0
    local x10p, y10p = x-dy1, y+dx1
    local iq, i0x, i0y, i1x, i1y = circlelinei(cx1,cy1, r1,
        x01p,y01p, dx0*inv_sw, dy0*inv_sw)
    if iq ~= "intersect" then
        return outermiterclip(dx0,dy0, x00,y00, s01,t01, x,y, s10,t10,
            x11,y11, dx1,dy1, style, ctol, output)
    end
    local ix, iy = closest(x,y, i0x,i0y, i1x,i1y)
    -- check if intersection is past miter limit
    local elx, ely, edx, edy = outerarcslimit(x01p,y01p, x,y, x10p,y10p,
        ix,iy, sw*style.miter_limit)
    -- if so
    if elx then -- and ely and delx and dely
        iq, i0x, i0y, i1x, i1y = circlelinei(cx1,cy1,r1,elx,ely,edx,edy)
        assert(iq == "intersect", "should have intersected")
        local e1x, e1y = closest(elx,ely, i0x,i0y, i1x,i1y)
        local e0x, e0y, e0w = linesi(elx,ely, elx+edx,ely+edy, x01p,y01p, ix,iy)
        assert(significant(e0w), "should have intersected")
        e0x, e0y = e0x/e0w, e0y/e0w
        output:linear_segment(x01p, y01p, e0x, e0y)
        output:linear_segment(e0x, e0y, e1x, e1y)
        arc(e1x, e1y, cx1, cy1, r1, x10p, y10p, output)
    else
        output:linear_segment(x01p, y01p, ix, iy)
        arc(ix, iy, cx1, cy1, r1, x10p, y10p, output)
    end
end

local function outerarcs(
    dx0, dy0, x00, y00, -- tangent direction and first wedge point
    s01, t01, x, y, s10, t10, -- curvatures and middle wedge point
    x11, y11, dx1, dy1, -- tangent directions and last wedge point
    style, ctol, output)
    -- ensure denominator is positive
    if t01 < 0 then s01, t01 = -s01, -t01 end
    if t10 < 0 then s10, t10 = -s10, -t10 end
    -- if either circle degenerates to a point curving inward
    if s01*FLT_MIN < -t01 or s10*FLT_MIN < -t10 then
        return outerround(dx0, dy0, x00, y00, s01, t01, x, y, s10, t10,
            x11, y11, dx1, dy1, style, ctol, output)
    end
    local sw = .5*style.width
    -- if either circle degenerates to a point curving outward
    if s01*sw > t01 or s10*sw > t10 then
        return outermiterclip(dx0, dy0, x00, y00, s01, t01, x, y, s10, t10,
            x11, y11, dx1, dy1, style, ctol, output)
    end
    local as01, as10 = abs(s01), abs(s10)
    -- c0 is circle
    if as01 > t01*FLT_MIN then
        -- c1 is circle
        if as10 > t10*FLT_MIN then
            return outerarcscircles(dx0,dy0, x00,y00, s01,t01, x,y, s10,t10,
                x11,y11, dx1,dy1, style, ctol, output)
        -- c1 is line
        else
            return outerarcscircleline(dx0,dy0, x00,y00, s01,t01, x,y, s10,t10,
                x11,y11, dx1,dy1, style, ctol, output)
        end
    -- c0 is line
    else
        -- c1 is circle
        if as10 > t10*FLT_MIN then
            return outerarcslinecircle(dx0,dy0, x00,y00, s01,t01, x,y, s10,t10,
                x11,y11, dx1,dy1, style, ctol, output)
        -- c1 is line
        else
            return outermiterclip(dx0,dy0, x00,y00, s01,t01, x,y, s10,t10,
                x11,y11, dx1,dy1, style, ctol, output)
        end
    end
end

function newjoin(outerjoin)
    return function(
        dx0, dy0, x00, y00, -- tangent direction and first wedge point
        s01, t01, x, y, s10, t10, -- curvatures and middle wedge point
        x11, y11, dx1, dy1, -- tangent directions and last wedge point
        style, ctol, output)
        local sw = .5*style.width
        local x01p, y01p = x-dy0, y+dx0
        local x10p, y10p = x-dy1, y+dx1
        -- if join is needed
        if x01p ~= x10p or y01p ~= y10p then
            if det2(dx0, dy0, dx1, dy1) > 0 then -- inner join
                local x00p, y00p = x00-dy0, y00+dx0
                local x00m, y00m = x00+dy0, y00-dx0
                local x11p, y11p = x11-dy1, y11+dx1
                local x11m, y11m = x11+dy1, y11-dx1
                if max(norm2(x-x00, y-y00), norm2(x-x11, y-y11)) < sw*sw
                    and det2(x11p-x, y11p-y, x-x00p, y-y00p) > 0 then
                    -- sweep join
                    if sq(dot2(x-x00, y-y00, x11-x, y11-y)) >
                       sq(ctol)*norm2(x-x00, y-y00)*norm2(x11-x, y11-y) then
                        -- approximation for small wedge angles
                        output:linear_segment(x01p, y01p, x, y)
                        output:linear_segment(x, y, x11p, y11p)
                        output:linear_segment(x11p, y11p, x00p, y00p)
                        output:linear_segment(x00p, y00p, x, y)
                        output:linear_segment(x, y, x10p, y10p)
                    else
                        -- full blown sweep
                        output:linear_segment(x01p, y01p, x, y)
                        output:linear_segment(x, y, x10p, y10p)
                        arc(x10p, y10p, x, y, sw, x01p, y01p, output)
                        output:linear_segment(x01p, y01p, x, y)
                        output:linear_segment(x, y, x10p, y10p)
                    end
                else
                    if segmentsq(x01p,y01p, x10p,y10p, x00p,y00p, x00m,y00m) or
                       segmentsq(x01p,y01p, x10p,y10p, x11p,y11p, x11m,y11m)
                       then
                        -- pivot join
                        output:linear_segment(x01p, y01p, x, y)
                        output:linear_segment(x, y, x10p, y10p)
                    else
                        -- bevel join
                        output:linear_segment(x01p, y01p, x10p, y10p)
                    end
                end
            else -- outer join
                -- if angle is too small, we don't need a fancy join
                if dot2(dx0, dy0, dx1, dy1) > ctol*sw*sw then
                    output:linear_segment(x01p, y01p, x10p, y10p)
                -- if there is no curvature information, then this is not a
                -- join between two segments, but rather between two
                -- subdivided segments. we simply sweep.
                elseif not s01 or not t01 or not s10 or not t10 then
                    outerround(dx0, dy0, x00, y00,
                          s01, t01, x, y, s10, t10,
                          x11, y11, dx1, dy1,
                          style, ctol, output)
                -- proceed with fancy join
                else
                    outerjoin(dx0, dy0, x00, y00,
                          s01, t01, x, y, s10, t10,
                          x11, y11, dx1, dy1,
                          style, ctol, output)
                end
            end
        else
        end
    end
end

local joins = {
    bevel = newjoin(outerbevel),
    round = newjoin(outerround),
    miter = newjoin(outermiter),
    miterclip = newjoin(outermiterclip),
    arcs = newjoin(outerarcs)
}

local function side(dashed, iter, first, last, style, ctol, closepath, output)

    local x00, y00, dx0, dy0
    local s01, t01
    local s10, t10
    local i = 0

    local function segment(x0,y0, dx,dy, x1,y1, output)
        -- if there was a previous segment, join wedge
        if x00 then -- and y00 and dx0 and dy0
            joins[style.join](dx0, dy0, x00, y00,
                              s01, t01, x0, y0, s10, t10,
                              x1, y1, dx, dy, style, ctol, output)
        end
        -- output offset segment
        local x10p, y10p = x0-dy, y0+dx
        local x11p, y11p = x1-dy, y1+dx
        if x10p ~= x11p or y10p ~= y11p then
            output:linear_segment(x10p, y10p, x11p, y11p)
        end
        -- save first point and tangent direction for next wedge
        x00, y00, dx0, dy0 = x0, y0, dx, dy
    end

    local sider = {}

    function sider:end_segment(s, t, x1, y1)
        s01, t01 = s, t
    end

    function sider:begin_segment(s, t, x0, y0)
        s10, t10 = s, t
    end

    function sider:linear_segment_with_length(x0, y0, len, x1, y1)
        -- TODO: use horizontal tangent direction if degenerate?
        assert(significant(len), "unmarked degenerate segment")
        local inv_len = .5*style.width/len
        local dx, dy = (x1-x0)*inv_len, (y1-y0)*inv_len
        segment(x0, y0, dx, dy, x1, y1, output)
        -- no curvatures available
        s01, t01, s10, t10 = nil, nil, nil, nil
    end

    function sider:degenerate_segment(x0, y0, sdx0, sdy0, sdx1, sdy1, x1, y1)
        if distinct(sdx0*sdy1, sdx1*sdy0) then
            local len0 = sqrt(sdx0*sdx0+sdy0*sdy0)
            -- TODO: use horizontal tangent direction if degenerate?
            assert(significant(len0), "degenerate slope in degenerate segment")
            local inv_len0 = .5*style.width/len0
            local dx, dy = sdx0*inv_len0, sdy0*inv_len0
            segment(x0, y0, dx, dy, x0, y0, output)
        else
        end
        local len1 = sqrt(norm2(sdx1, sdy1))
        -- TODO: use horizontal tangent direction if degenerate?
        assert(significant(len1), "degenerate slope in degenerate segment")
        local inv_len1 = .5*style.width/len1
        dx, dy = sdx1*inv_len1, sdy1*inv_len1
        segment(x0, y0, dx, dy, x1, y1, output)
        -- no curvatures available
        s01, t01, s10, t10 = nil, nil, nil, nil
    end

    iter(dashed, sider, first+1, last-1)

    if closepath then output:end_closed_contour(x01p, y01p, nil) end
end

local function join(dashed, iter1, first1, last1, iter2, first2, last2,
    style, ctol, moveto, output)

    local joiner = {}

    local x0, y0, x1, y1, dx, dy, len, s, t

    function joiner:end_segment(s, t, x1, y1)
    end

    function joiner:begin_segment(ss, st, x0, y0)
        s, t = ss, st
    end

    function joiner:linear_segment_with_length(sx0, sy0, slen, sx1, sy1)
        dx, dy = sx1-sx0, sy1-sy0
        len = slen
        x0, y0 = sx0, sy0
        x1, y1 = sx1, sy1
        return true -- abort iteration
    end

    function joiner:degenerate_segment(sx0, sy0, dx0, dy0, dx1, dy1, sx1, sy1)
        dx, dy = dx0, dy0
        len = sqrt(dx0*dx0 + dy0*dy0)
        x0, y0 = sx0, sy0
        x1, y1 = sx1, sy1
        assert(significant(len), "degenerate slope in degenerate segment")
        return true -- abort iteration
    end

    s, t = nil, nil
    iter1(dashed, joiner, first1+1, last1-1)

    local inv_len = .5*style.width/len
    local x00, y00, dx0, dy0 = x1, y1, -inv_len*dx, -inv_len*dy
    local x, y = x0, y0
    local s01, t01 = -s, t

    s, t = nil, nil
    iter2(dashed, joiner, first2+1, last2-1)

    local inv_len = .5*style.width/len
    local x11, y11, dx1, dy1 = x1, y1, inv_len*dx, inv_len*dy
    assert(x0 == x and y0 == y, "disconnected join")
    local s10, t10 = s, t

    if moveto then
        output:begin_closed_contour(nil, x-dy0, y+dx0)
    end

    joins[style.join](
        dx0, dy0, x00, y00,
        s01, t01, x, y, s10, t10,
        x11, y11, dx1, dy1,
        style, ctol, output)

end

local function advancedashfirst(path, first)
    assert(path.instructions[first] == "begin_dash")
    offset = path.offsets[first]
    len = path.data[offset]
    return first + len + 1
end

local function rewinddashlast(path, last)
    -- move end backwards
    assert(path.instructions[last] == "end_dash")
    local offset = path.offsets[last]
    local len = path.data[offset+2]
    return last - len - 1
end

function _M.offset(dashed, style, atol, output)
    local ctol = math.cos(math.rad(atol))
    -- if width is too small, return empty path
    if negligible(style.width) then return output end
    local iter, riter = dashed.iterate, dashed.riterate
    -- otherwise, proceed offseting each contour independently
    for cf, cl in dashed:contours() do
        -- if contour is closed, we can do all internal dashes
        -- as if it was open. however, the first and last dashes
        -- are connected into a single dash, and the entire
        -- contour may in fact consist of a single dash.
        if dashed.instructions[cf] == "begin_closed_contour" then
            local idf = advancedashfirst(dashed, cf+1)
            local idl = rewinddashlast(dashed, cl-1)
            -- do internal dashes
            for df, dl in
                dashed:dashes(idf, idl) do
                cap(dashed, iter, df, dl, style, ctol, true, output)
                side(dashed, iter, df, dl, style, ctol, false, output)
                cap(dashed, riter, df, dl, style, ctol, false, output)
                side(dashed, riter, df, dl, style, ctol, true, output)
            end
            -- if there was more than one dash
            if idf < idl then
                -- connect first and last dashes into one
                cap(dashed, iter, idl+1, cl-1, style, ctol, true, output)
                side(dashed, iter, idl+1, cl-1, style, ctol, false, output)
                join(dashed, riter, idl+1, cl-1,
                             iter, cf+1, idf-1, style, ctol, false, output)
                side(dashed, iter, cf+1, idf-1, style, ctol, false, output)
                cap(dashed, riter, cf+1, idf-1, style, ctol, false, output)
                side(dashed, riter, cf+1, idf-1, style, ctol, false, output)
                join(dashed, iter, cf+1, idf-1,
                             riter, idl+1, cl-1, style, ctol, false, output)
                side(dashed, riter, idl+1, cl-1, style, ctol, true, output)
            -- if there was just one dash
            elseif cf+1 < cl-1 then
                -- add two independent offset contours
                join(dashed, riter, cf+1, cl-1,
                             iter, cf+1, cl-1, style, ctol, true, output)
                side(dashed, iter, cf+1, cl-1, style, ctol, true, output)
                join(dashed, iter, cf+1, cl-1,
                             riter, cf+1, cl-1, style, ctol, true, output)
                side(dashed, riter, cf+1, cl-1, style, ctol, true, output)
            end
        -- if the contour is open, then all dashes are independent
        else
            for df, dl in
                dashed:dashes(cf+1, cl-1) do
                cap(dashed, iter, df, dl, style, ctol, true, output)
                side(dashed, iter, df, dl, style, ctol, false, output)
                cap(dashed, riter, df, dl, style, ctol, false, output)
                side(dashed, riter, df, dl, style, ctol, true, output)
            end
        end
    end
    return output
end

return _M
